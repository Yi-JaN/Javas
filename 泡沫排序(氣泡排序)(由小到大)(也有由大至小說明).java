import java.util.Arrays;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner scn=new Scanner(System.in);
       int []n=new int[5];   //讓int給定new int 5個值
       for(int i=0;i<5;i++){   //n先取一維陣列,裡頭有5個值
           n[i]=scn.nextInt();
       }                         //下面開始就是進行泡沫排序!
       for(int j=0;j<n.length;j++){//外圈for是看我陣列n有幾個值,並且循環n次,然後每次循環外圈帶動目前內圈做排序,排序到外圈結束,也是最完美的時候
           for(int k=0;k<n.length-1;k++){ //內圈進行由小至大排序,注意:外圈run幾次,那麼這內圈就要持續排由小至大幾次,排到最完美為止
               if(n[k]>n[k+1]){  //這裡是比較區,由小至大是n[k]>n[k+1] 由大至小是n[k]<n[k+1]
                   int v=n[k];    //如果if符合 就互換目前的n位於的k值跟n[k+1]的值
                   n[k]=n[k+1];
                   n[k+1]=v;
               }
           }             //注意:為什麼for k裡n.length-1,為什麼要-1呢? 因為排到最後一個值,後面就沒值做排序比較
       }      //最後一個值就最後一個值了,哪來的最後一個值在往後取值做排序,ex:假設n.length為5 0就跟1比 在來1跟2比 2跟3 3跟4 之後4就最後了
       for(int a=0;a<n.length;a++){                                      //最後後面就沒值可以+1了
           System.out.print(n[a]+" ");  //最後把完美排序ok的一維陣列值 一個一個列印出來
       }
       System.out.println();
    }
}
/*
補充:那為什麼要加外圈for的原因是因為如果不加 那他內圈排出來不管是由小至大還由大至小 都只有循環排1次而且是排半成品出來,所以如果要一個一個依照由小至大
或由大至小 那一定要放外圈for 看幾個n.length值 外圈就跟著循環幾次 之後外圈帶動內圈排出最完美的由小到大或由大至小
題目:泡沫排序法,(氣泡排序)
5 2 3 7 1                                             假設n.length為5  n=[5,2,3,7,1]
A:->(由大至小)7 5 3 2 1               外圈帶動內圈循環次數    由小至大(原本)    由小至大(更改後)
A:->(由小至大)1 2 3 5 7                    j=0   1         5,2,3,7,1  ->  2 3 5 1 7
                                         j=1   2        2,3,5,1,7  ->  2 3 1 5 7
                                         j=2   3        2,3,1,5,7  ->  2 1 3 5 7
                                         j=3   4        2,1,3,5,7  ->  1 2 3 5 7
                                         j=4   5        1,2,3,5,7  ->  1 2 3 5 7 <-5次完畢最終答案
 */
